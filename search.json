[{"title":"ast反混淆之常用api的使用","url":"/2026/02/11/ast反混淆之常用api的使用/","content":"# ast反混淆杂谈（二）\n\n本期我们主要探讨三个方向：\n（1）Path\n（2）types\n（3）scope\n\n## Path\n\n### 1.什么是Path\n\nPath并不是 AST 树物理结构的一部分，而是遍历算法在运行时生成的对象。它是一个封装了 Node 的容器。它记录了从根节点（Root）到当前节点（Node）的所有连接信息。\n\n通常，我们会在`traverse`中使用它。\n\n```js\ntraverse(ast, {\n    StringLiteral: function (path) {\n        //无论你在定义函数时给参数起了什么名字，Babel 传进来的永远是那个刚创建好的 Path 对象\n        if (path.node.extra && path.node.extra.raw !== path.node.extra.rawValue) {\n            path.replaceWith(types.stringLiteral(path.node.extra.rawValue));\n        }\n    }\n});\n```\n\n这里举了处理如同这样的字符型字面量\n`'\\u5927\\u5a01'+'\\u5929\\u9f99'`\n通过ast反混淆的处理还原为了`大威天龙`\n\n其中，就是通过**遍历器**和**访客函数**，找到所有类型为`StringLiteral`的节点，对其进行判断，从而可以定制化的进行处理。\n\n### 2. 什么是traverse\n\n我们可以从三个角度来讲解traverse的原理和作用\n\n- 行为本质：深度优先搜索 (DFS)\n  >在底层逻辑上，`traverse` 执行的是 `Depth-First Search (DFS)`。它不是随机乱跑的，而是从根节点（Program）开始，像探险一样沿着树的分支一直走到最深处的叶子节点（比如一个数字或字符），然后再回溯。\n- 设计模式：访问者模式\n  >Element (元素)：指 AST 上的各个 Node。\n   Visitor (访问者)：访客函数。\n   Traverser (遍历器)：traverse 模块\n- 运行状态：上下文驱动\n  >traverse 不仅仅是“走过”这些节点，它在遍历的过程中，动态地维护着一整套上下文环境。 它每走一步，都会实时更新Path栈和Scope链\n\n\n### 3. path的常用节点使用\n```\n// --- 基础属性查询 ---\n// path.node          // [当前节点] 访问 Path 包装下的原始 AST 节点。\n// path.type          // [节点类型] 获取当前节点的字符串类型名（如 'Identifier'），等同于 path.node.type。\n// path.key           // [索引键名] 当前节点在父级容器中的属性名或数组索引（如 'left' 或 0）。\n// path.container     // [所属容器] 获取当前节点所在的父级属性对象或节点数组（包含自身及兄弟节点）。\n\n// --- 关联节点定位 ---\n// path.parent        // [父级节点] 直接获取父级 AST 节点（仅含数据）。\n// path.parentPath    // [父级路径] 获取父级的 NodePath 对象（可链式调用 path 方法，反混淆常用）。\n// path.scope         // [作用域句柄] 访问当前节点所属的词法作用域，用于变量绑定分析（Binding）和重命名。\n\n// --- 逻辑计算与判定 ---\n// path.evaluate()    // [静态分析] 尝试对表达式进行常量折叠计算，返回一个包含 { confident, value } 的结果对象。\n// path.toString()    // [代码还原] 将当前路径对应的 AST 子树反向生成为标准的源代码字符串。\n\n// --- 树状遍历与搜索 ---\n// path.findParent()      // [向上回溯] 递归查找符合条件的父级路径（不含自身），直到根节点。\n// path.find()            // [向上搜索] 从当前路径开始，递归向上查找符合条件的路径（含自身）。\n// path.getFunctionParent() // [函数溯源] 快速定位最近的一层函数类型父节点（如 FunctionDeclaration）。\n// path.traverse(visitor) // [局部遍历] 以当前节点为根，启动一个子级的深度优先搜索（DFS）流程。\n\n// --- 节点转换与操作 (反混淆核心) ---\n// path.replaceWith(node)          // [单节点替换] 用一个新的 AST 节点替换当前节点，保持树的拓扑结构一致。\n// path.replaceWithMultiple(nodes) // [多节点替换] 用一个节点数组替换当前单个节点（常用于将一行语句拆分为多行）。\n// path.replaceInline(nodes)       // [智能替换] 自动识别单/多节点并执行替换，是更通用的 API 封装。\n// path.remove()                   // [节点剪枝] 从 AST 树中物理删除当前节点，并自动修复父级引用。\n// path.insertBefore(nodes)        // [前序插入] 在当前节点同级的上方插入一个或多个节点。\n// path.insertAfter(nodes)         // [后续插入] 在当前节点同级的下方插入一个或多个节点。\n```\n\n### 4.综合运用\n我们还是使用刚才的那个例子来进行逐步解析，这个方法适用于解密函数的反混淆，控制流平坦化的扁平化处理，字符串十六进制的转换，代理函数的还原等。此处为字符串十六进制反混淆。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img12@main/2026/02/11/1770781801059-e52e035f-056c-4c60-af9f-9b73c5326506.png)\n根据 AST 树状图不难看出\n我们想要的字符串字面量（StringLiteral）\n可能嵌套在\n二元表达式（BinaryExpression）或\n表达式语句（ExpressionStatement）中。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img10@main/2026/02/11/1770782276593-d7831b21-5e76-4a27-84a3-23af9d4ade73.png)\n进入 StringLiteral 节点深处，我们可以发现两个关键属性：\n\nextra.raw: 混淆后的十六进制形式，例如 '\\x61'。\n\nextra.rawValue: Babel 解析后的原始文本，例如 'a'\n\n接下来我们只需要根据这样的节点信息来编写通用的反混淆代码。\n\n\n```js\ntraverse(ast, {\n    //我们通过对比 extra.raw（原始文本）与 extra.rawValue（解析后的实际值），来精准识别出那些被“转义混淆”过的字符串。\n    StringLiteral: function (path) {\n        if (path.node.extra && path.node.extra.raw !== path.node.extra.rawValue) {\n            console.log(path.toString())\n          //通过日志输出可以查验我们想要操作的节点是否正确，它能让你直观地看到当前处理的代码长什么样\n            path.replaceWith(types.stringLiteral(path.node.extra.rawValue));\n          //通过path.replaceWith将原有节点进行替换，types用法见下文。\n        }\n    }\n});\n```\n\n### 5. 常用类型名称及描述\n\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img7@main/2026/02/11/1770782713530-5bca391a-0fe8-4cfb-85f7-ba4b398458d6.png)\n\n\n\n## types\n\n### 1.常用types的is判断\n```js\n// 语法：types.is[节点类型](待检测的节点)\n// 返回：Boolean (true/false)\n\nif (types.isStringLiteral(path.node)) {\n    // 确定是字符串，可以放心访问 path.node.value\n}\n\nif (types.isBinaryExpression(path.node)) {\n    // 确定是二元表达式，可以放心访问 path.node.left 和 path.node.right\n}\n```\n我们还可以看一下源码的写法\n```ts\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"StringLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n```\n它比` node.type === '...' `更安全，因为它内置了 null 检查。\n### 2. 字面量还原\n这些方法用于将解密后的值还原为代码中的常量\n\n|   方法名    |  说明     |     示例代码  |    还原后的源码   |\n| --- | --- | --- | --- |\n|    `types.stringLiteral(v)`   |   构造字符串    |   ` types.stringLiteral(\"hello\") `  |  \"hello\"     |\n|    `types.numericLiteral(v)`\t   |     构造数字\t |     `types.numericLiteral(123)`\t  |  123      |\n|    `types.booleanLiteral(v)`\t   |    构造布尔值\t   |   `types.booleanLiteral(true)`\t   |  true      |\n|    `types.identifier(v)`   |     构造变量名/标识符  |    `types.identifier(\"user\")`   |    user   |\n\n\n\n### 3. 表达式还原\n当你需要把混淆的调用还原为简单的运算或取值时使用。\n\n|     方法名   |   说明     |    示例代码    |   还原后的源码    |\n| --- | --- | --- | --- |\n|    `types.binaryExpression(op, l, r)`   |   构造二元运算    |   `types.binaryExpression(\"+\", a, b)`    |  a + b     |\n|   `types.callExpression(callee, args)`    |    构造函数调用   |    `types.callExpression(func, [arg1])`   |   func(arg1)    |\n|    `types.memberExpression(obj, prop)`   |  构造对象取值     |    `types.memberExpression(obj, prop)`   |   obj.prop 或 obj[prop]    |\n|   `types.unaryExpression(op, arg)`   |   构造一元运算    |  `types.unaryExpression(\"!\", a)`     |    !a   |\n\n### 4. 剩余好用的API\n(1)`types.matchesPattern(node, pattern, allowPartial)`\n功能：判断一个节点是否匹配指定的成员表达式路径\n实战场景：识别并拦截特定的解密工具类方法。\n ```js\n // 检查当前节点是不是 console.log\nif (types.matchesPattern(path.node, \"console.log\")) {\n    // 逻辑处理\n}\n ```\n (2)`types.cloneNode(node)`\n 功能：深度克隆一个节点及其子节点。\n 实战场景：在还原代理函数或展开表达式时，确保新生成的节点是独立的，不会在修改 A 时意外影响到 B。\n (3)`types.toComputedKey(node)`\n 举例：混淆代码喜欢把 `obj.prop `变成 `obj[\"prop\"]`\n 功能：将节点转换为有效的对象属性键（处理标识符和字符串字面量之间的转换）。\n 实战场景：统一属性访问方式，方便后续的静态分析。\n## Scope\n### 1. 什么是 Scope？\n在 Babel 中，Scope 是一个对象，它代表了代码中的词法作用域（Lexical Scope）。\n\n每一个函数、每一个块级（Block，如 if 或 for）都会生成一个新的 Scope。它负责记录当前区域内定义了哪些变量，以及这些变量被谁引用了。\n\n### 2.有了 Scope 可以完成哪些操作\n\n#### （1）变量重命名还原（Rename）\n\n- 场景：混淆代码喜欢把变量改成 `_0x1abc`\n\n- 操作：`path.scope.rename(\"_0x1abc\", \"decoded_str\")`\n\n- 作用：它不仅改掉定义的那个名字，还会自动把全篇所有引用这个变量的地方全部改掉，且保证不会污染其他同名变量。\n#### （2）解密函数批量内联\n- 场景：你发现` _0x55aa` 是解密函数。\n- 操作：通过 `path.scope.getBinding(\"_0x55aa\")` 拿到它的 referencePaths。\n- 作用：你直接遍历这些路径，挨个执行解密并替换，不需要全局扫描字符串。\n```js\nvar _0x55aa = function(a, b) { ... }; // 定义解密函数\n\nvar alias = _0x55aa;                  // 引用 1：赋值给别名\nconsole.log(_0x55aa);                 // 引用 2：作为参数传递\nvar str = _0x55aa('0x1', '0x2');      // 引用 3：真正的函数调用\n```\n>对代码块举例说明`path.scope.getBinding(\"_0x55aa\").referencePaths` 时，你会拿到 3 个 Path 对象。\n>>引用 1 的 Path 指向的是 `_0x55aa` 这个 Identifier（标识符）。它的父级是 VariableDeclarator。\n>>引用 2 的 Path 指向的是 `_0x55aa` 这个 Identifier。它的父级是 CallExpression (console.log)。\n>>引用 3 的 Path 指向的是 `_0x55aa` 这个 Identifier。它的父级才是真正的解密调用 CallExpression。\n\n我们来对上面这个代码块来做一次还原处理\n```js\n// 1. 获取解密函数的“档案”\nconst binding = path.scope.getBinding(\"_0x55aa\");\n//这个binding.referencePaths可以理解为拿到了所有引用了这个变量的 Path 对象\n// 2. 遍历所有引用了该变量的路径 (List)\nfor (let refPath of binding.referencePaths) {\n    \n    // 3. 拿到当前引用的父级路径\n    const parentPath = refPath.parentPath;\n\n    // 4. 判断逻辑：父级是不是一个函数调用？且当前引用是不是那个被叫名字的人（callee）？\n    if (parentPath.isCallExpression() && parentPath.node.callee === refPath.node) {\n        \n        // 5. 提取参数执行解密（假设参数是第一个）\n        const arg1 = parentPath.node.arguments[0].value;\n        const arg2 = parentPath.node.arguments[1].value;\n        const result = _0x55aa(arg1,arg2); \n        \n        // 6. 替换掉整个调用表达式\n        parentPath.replaceWith(types.stringLiteral(result));\n    }\n}\n```\n大家可以将举例代码块粘贴于`https://astexplorer.net/`\n进行配套理解本段反混淆代码\n这样做的好处是在混淆代码过长，或者有不同函数局部变量导致函数名重复时，实现真实有效的反混淆\n#### （3）删除死代码\n- 场景：很多混淆逻辑会生成一堆从未调用的函数。\n- 操作：检查 `binding.referenced === false`\n- 效果：直接 path.remove()，代码瞬间清爽。\n```js\nvar _0x55aa = function(a, b) { return a + b; }; // 真正的解密函数\nvar _0x123456 = _0x55aa;                       // 垃圾别名：定义了但没人用\nvar _0x999999 = \"I am useless\";                // 纯垃圾变量\n\nconsole.log(_0x55aa(1, 2));                    // 只有这里用到了 _0x55aa\n```\n```js\ntraverse(ast, {\n    // 我们可以针对“变量声明”进行扫描\n    VariableDeclarator(path) {\n        // 1. 获取当前变量名的标识符（Identifier）\n        const { id } = path.node;\n        \n        // 2. 如果不是标识符（比如是解构赋值），跳过\n        if (!types.isIdentifier(id)) return;\n\n        // 3. 索取该变量的“档案”\n        const binding = path.scope.getBinding(id.name);\n\n        // 4. 核心判定：如果没有被引用，且不是全局变量\n        if (binding && !binding.referenced) {\n            console.log(`发现死代码：变量 ${id.name} 无人引用，正在执行清理...`);\n            \n            // 5. 物理删除该节点\n            path.remove();\n        }\n    }\n});\n```\n#### (4) scope.getBinding()\n单独拿出来说是因为其本身就很复杂\n\n当你执行 getBinding 时，Babel 会瞬间把这个变量在整个作用域链（Scope Chain）上的所有信息抽调出来。\n\n它有一个向上溯源的属性，会一直向父级，爷爷级向上找，直到全局作用域。\n```js\n// binding = path.scope.getBinding(\"变量名\")\n\n// 1. binding.path \n// 这是一个指向“声明节点（Declaration）”的 NodePath 对象。\n// 用途：你可以直接通过 binding.path.node 获取变量的初始化值。\n\n// 2. binding.referencePaths \n// 这是一个由 NodePath 对象组成的 Array（数组）。\n// 用途：记录了全篇所有引用该变量的地方。\n\n// 3. binding.constant\n// 这是一个 Boolean（布尔值）。\n// 用途：如果变量定义后从未出现在赋值号左侧（没被改过），则为 true。\n```\n### 3.常用api汇总\n\n|     API 方法  |     作用说明  |\n| --- | --- |\n|    path.scope.getBinding(name)   |   获取某个变量的详细档案（Binding）。    |\n|    path.scope.hasBinding(name)   |   判断当前作用域（含父级）是否定义了该变量。    |\n|    path.scope.hasOwnBinding(name)   |    只在当前作用域寻找定义。   |\n|    path.scope.generateUid(name)   |   生成一个当前作用域内唯一的变量名（防冲突）。    |\n|     path.scope.dump()  |    调试利器！ 打印当前作用域的所有变量信息到控制台。   |\n\n\n## 总结\n在代码的废墟中，所有的混乱都遵循着某种秩序。而 AST，就是我们重建秩序的蓝图。\n\n由于 AST 混淆技术博大精深，本人水平有限，文中若有疏漏或理解偏差之处，恳请各位前辈大佬不吝赐教，我们评论区见。\n\n希望我的内容能够帮助到您，如果有侵权或冒犯的地方请私信我。\n\n最后，愿我们在高处相见，亦或在深处重逢。\n- [什么是ast，怎么用ast，ast的一些思考](https://mp.weixin.qq.com/s/LUuv2QEvOP2tkzQGx8iRGg)\n\n\n---\n\n\n   ![](https://fastly.jsdelivr.net/gh/bucketio/img4@main/2026/02/11/1770791852679-7134300f-96f4-4f02-a06a-86e130e060c5.jpg)\n\n","categories":["featTest"]},{"title":"一切的开始","url":"/2026/01/13/第一篇博客/","content":"# 一级标题\n## 二级标题\n### 三级标题","categories":["featTest"]}]