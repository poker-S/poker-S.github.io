[{"title":"爱某网逆向分析全流程","url":"/2026/02/26/笔记/","content":"\n\n# 爱某网逆向分析全流程\n\n---\n**提示！本文章仅供学习交流，严禁用于任何商业和非法用途，未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责，如有侵权，可联系本文作者删除！**\n---\n网站链接 : \n`aHR0cHM6Ly93d3cuYWlnZWkuY29tL3NvdW5kL2NsYXNzLwo=`\n## 一、抓包分析\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img4@main/2026/02/25/1772017856851-f5b54c0f-fa73-4942-82b1-e254a0c907d7.png)\n\n可以发现有着四个可疑的地方，分别是一个接口，一个音频，和两个 mp3，这时候我们可以通过 AI 的方式来进行排查。\n\n通过询问 AI，接口可能是个防御措施咱们先不用管，我们想要拿到音频文件，但是很显然音频有加密，那就要分析加密是哪来的，所以我们继续看这两个 mp3 接口，通过分析其中的参数，我们在其中的一个 mp3 的参数中找到了一串密文，抱着尝试的心我打开了 base64 解码在线工具，很不巧的是，让我猜中了，就是一串 base64。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img6@main/2026/02/25/1772018510284-2d291024-9d5b-46fc-91ae-0768d2899be7.png)\n\n那么现在我们的目的很明确了，就是逆这个 mp3 接口，废话不多说，直接开干。\n\n---\n\n## 二、逆向 mp3 接口\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img18@main/2026/02/25/1772018622377-05885648-7f52-4bd2-8728-55c523fd8bb7.png)\n\n由于加密参数是个没有特征的字母，所以咱们直接翻堆栈，从 fget 中点过去，找到了 ajax。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img15@main/2026/02/25/1772018800141-74bb1cf7-0202-4031-87c1-dec7261320f2.png)\n\n打断点，找参数，找到了之后开始扣代码，由于这个网站的加密不是那么难，所以就不搞补环境了，醇酸我也不会。嗯....开始吧\n\n这里有个细节需要注意一下，在 ajax 打断点的时候，第一次尝试，是走了两遍 ajax，那么我们就需要去留意一下，通过参数内容，我们翻一下抓包，分析得到，第一次的 ajax 是我们想要得到的 mp3 接口参数，而第二次的 ajax 是另一个 mp3 接口。那个 mp3 接口我不知道是干什么的，由于是边做边写的文章，所以如果后续用到了的话会再进行分析。\n\n---\n\n## 三、分析加密参数\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img8@main/2026/02/25/1772019750478-6fbd5309-df10-4e1f-b545-c2735bfe9003.png)\n\n可以给大家说一下这个思考过程，供大家参考。首先我们要的参数就是这个 E，那么 E 分为两部分，一个是这个加密函数，另一个是这个加密参数。我们可以先从参数入手，那么我是先打断点翻堆栈，发现这个地方不是那么好入手。所以我会再去仔细看这个参数。从这个箭头可以看出，我会先去想这个 ud 是怎么来的，然后我们就往上看。发现第一次出现是在这个 dfu 函数处理之后。那么很显然，这个是加密参数的加密函数。然后这时候去看这个 dfu 加密参数都有什么，别看它有七个参数，实际上后面三个都是 undefined。前四个分别是：\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img5@main/2026/02/25/1772020019720-55104209-f025-46ee-9625-276c857c1166.png)\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img9@main/2026/02/25/1772020073748-2af4ff47-49a1-41bc-b408-57c7aca665c1.png)\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img14@main/2026/02/25/1772020089746-9ca80713-97f3-49be-b9d1-5991ec8f12eb.png)\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img18@main/2026/02/25/1772020113566-e331c510-36fc-41e1-b852-04819b1e17b9.png)\n\n按照这个照片顺序，简单说一下我的猜测：\n\n- 这个 C，一定是固定的，这个是接口名称\n- 第二个参数暂时可以认为是这个音频的 id，之后会详细的去确认\n- 第三个参数，很明显是个时间戳，可以用 `console.log(Date.now())` 去验证一下这个时间戳的长度是不是正常的，因为有些时间戳会 `/1000` 也说不定\n- 第四个参数很明显是个 token，猜测是根据账号来分配的 token\n\n---\n\n## 四、参数验证与确认\n\n那么猜测结束，我去验证了一下，怎么验证的呢，时间戳打印验证，发现不是很相近，而且不同的音频返回的 token 也不一样。那么咱们可以尝试抓包搜索，如果搜不到的话我可能会去尝试使用\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img6@main/2026/02/25/1772020811035-be0ad1e6-c37c-4f0d-99f2-ed4ce0d2e869.png)\n\n这个功能，最终，效果是一致的，为什么我会说可以会用这个功能呢，因为前面我也说过，有个参数很像歌曲 id，之前做某易云的时候我就用过这招，效果是显著的。最后才会想到去翻堆栈找参数。\n\n实际上，抓包做接口成为了习惯，但是我们往往容易忘记，本身页面也是有信息存在的，也是可用的。\n\n至于这四个参数的抓取，就不在这篇文章里了。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img14@main/2026/02/25/1772021356392-026fe384-e18e-4790-a818-08eb30059e20.png)\n\n好，我们在 IDE 里固定这四个值。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img2@main/2026/02/25/1772021922867-022bc7a9-8b49-460d-9247-1be2d51a3f1e.png)\n\n剩下的部分，就是缺什么补什么了。\n\n---\n\n## 五、处理 jQuery 依赖\n\n然后就来到了，一个比较难处理的地方，本处在此鸣谢时一姐的星球知识！！！！\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img12@main/2026/02/25/1772029970812-7ec30ec7-8be2-4091-b309-40f0f73e93d9.png)\n\n就会看到这个 juquery，那怎么处理呢，在此再次鸣谢时一姐。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img10@main/2026/02/25/1772030164656-512cb3ed-0e59-4655-bb42-7bb4194bd0b1.png)\n\n我们来到这个 juquery，把外面这层自执行函数给扒下来单独做一个文件来进行调试。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img4@main/2026/02/25/1772030314833-bdc1c648-06a2-49d1-be5e-f09372cab5cd.png)\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img7@main/2026/02/26/1772080540747-74c15ed4-483f-4d80-a44c-32bf28ecec4d.png)\n\n通过对比可以发现，这和 juquery 中 x 是一样的，也就是说，我们把 juquery 中的 x 抠出来就算完成了，此处为缺什么补什么，最后将 x 赋值给 `$`。然后整体带回解密函数。再进行缺什么补什么的扣代码细节。\n\nv 这个参数，就算是补完了，但是此时是请求不过的，因为接口还有个请求头的参数加密。\n\n---\n\n## 六、请求头加密分析\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img8@main/2026/02/26/1772093454570-23bcc56b-a951-47a0-bdb0-b0582c6b060d.png)\n\n这个呢，可以通过搜索的方式来寻找。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img10@main/2026/02/26/1772093512524-136816ea-1db7-4c07-952b-20015aa330f9.png)\n\n然后打断点。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img15@main/2026/02/26/1772093553254-6a98b950-19fc-47a0-be34-515a4d037d24.png)\n\n发现这个 `pIii111lllE`，然后全局一搜索，这个 id 是全局唯一的，并且，在后续请求的时候，发现只有第一页有这个 id，因为这个翻页是通过异步渲染接口来进行的，但是请求第一页的接口是没有这个 id 的，只能通过先请求再 xpath 再当成参数传入 js。\n\n由于之前已经扣过代码了，所以一起传入 js，缺什么补什么，然后获取 v 参数和 headers 参数。\n\n---\n\n## 七、获取音频地址\n\n最后就能顺利的拿到 message。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img13@main/2026/02/26/1772093880921-9d8391f7-e5b2-43ce-8a75-6c9964704489.png)\n\n前面已经说过了，这个 message 是 base64 编码，所以做解码处理就能得到音频接口的请求地址。\n\n但是光复制请求地址去浏览器打开是没办法拿到音频的，因为这个网站还有防盗链限制。此时带上完整的请求头即可。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img8@main/2026/02/26/1772094461908-db066e7b-7c46-4163-8064-0d8b460499b2.png)\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img0@main/2026/02/26/1772094487287-79eba751-59a4-4c56-a45e-82fb248f2c1b.png)\n## 总结\n\n由于爬虫逆向技术博大精深，本人水平有限，文中若有疏漏或理解偏差之处，恳请各位前辈大佬不吝赐教，我们评论区见。\n\n最后，愿我们在高处相见，亦或在深处重逢。","categories":["featTest"]},{"title":"ast反混淆之常用api的使用","url":"/2026/02/11/ast反混淆之常用api的使用/","content":"# ast反混淆杂谈（二）\n\n本期我们主要探讨三个方向：\n（1）Path\n（2）types\n（3）scope\n\n## Path\n\n### 1.什么是Path\n\nPath并不是 AST 树物理结构的一部分，而是遍历算法在运行时生成的对象。它是一个封装了 Node 的容器。它记录了从根节点（Root）到当前节点（Node）的所有连接信息。\n\n通常，我们会在`traverse`中使用它。\n\n```js\ntraverse(ast, {\n    StringLiteral: function (path) {\n        //无论你在定义函数时给参数起了什么名字，Babel 传进来的永远是那个刚创建好的 Path 对象\n        if (path.node.extra && path.node.extra.raw !== path.node.extra.rawValue) {\n            path.replaceWith(types.stringLiteral(path.node.extra.rawValue));\n        }\n    }\n});\n```\n\n这里举了处理如同这样的字符型字面量\n`'\\u5927\\u5a01'+'\\u5929\\u9f99'`\n通过ast反混淆的处理还原为了`大威天龙`\n\n其中，就是通过**遍历器**和**访客函数**，找到所有类型为`StringLiteral`的节点，对其进行判断，从而可以定制化的进行处理。\n\n### 2. 什么是traverse\n\n我们可以从三个角度来讲解traverse的原理和作用\n\n- 行为本质：深度优先搜索 (DFS)\n  >在底层逻辑上，`traverse` 执行的是 `Depth-First Search (DFS)`。它不是随机乱跑的，而是从根节点（Program）开始，像探险一样沿着树的分支一直走到最深处的叶子节点（比如一个数字或字符），然后再回溯。\n- 设计模式：访问者模式\n  >Element (元素)：指 AST 上的各个 Node。\n   Visitor (访问者)：访客函数。\n   Traverser (遍历器)：traverse 模块\n- 运行状态：上下文驱动\n  >traverse 不仅仅是“走过”这些节点，它在遍历的过程中，动态地维护着一整套上下文环境。 它每走一步，都会实时更新Path栈和Scope链\n\n\n### 3. path的常用节点使用\n```\n// --- 基础属性查询 ---\n// path.node          // [当前节点] 访问 Path 包装下的原始 AST 节点。\n// path.type          // [节点类型] 获取当前节点的字符串类型名（如 'Identifier'），等同于 path.node.type。\n// path.key           // [索引键名] 当前节点在父级容器中的属性名或数组索引（如 'left' 或 0）。\n// path.container     // [所属容器] 获取当前节点所在的父级属性对象或节点数组（包含自身及兄弟节点）。\n\n// --- 关联节点定位 ---\n// path.parent        // [父级节点] 直接获取父级 AST 节点（仅含数据）。\n// path.parentPath    // [父级路径] 获取父级的 NodePath 对象（可链式调用 path 方法，反混淆常用）。\n// path.scope         // [作用域句柄] 访问当前节点所属的词法作用域，用于变量绑定分析（Binding）和重命名。\n\n// --- 逻辑计算与判定 ---\n// path.evaluate()    // [静态分析] 尝试对表达式进行常量折叠计算，返回一个包含 { confident, value } 的结果对象。\n// path.toString()    // [代码还原] 将当前路径对应的 AST 子树反向生成为标准的源代码字符串。\n\n// --- 树状遍历与搜索 ---\n// path.findParent()      // [向上回溯] 递归查找符合条件的父级路径（不含自身），直到根节点。\n// path.find()            // [向上搜索] 从当前路径开始，递归向上查找符合条件的路径（含自身）。\n// path.getFunctionParent() // [函数溯源] 快速定位最近的一层函数类型父节点（如 FunctionDeclaration）。\n// path.traverse(visitor) // [局部遍历] 以当前节点为根，启动一个子级的深度优先搜索（DFS）流程。\n\n// --- 节点转换与操作 (反混淆核心) ---\n// path.replaceWith(node)          // [单节点替换] 用一个新的 AST 节点替换当前节点，保持树的拓扑结构一致。\n// path.replaceWithMultiple(nodes) // [多节点替换] 用一个节点数组替换当前单个节点（常用于将一行语句拆分为多行）。\n// path.replaceInline(nodes)       // [智能替换] 自动识别单/多节点并执行替换，是更通用的 API 封装。\n// path.remove()                   // [节点剪枝] 从 AST 树中物理删除当前节点，并自动修复父级引用。\n// path.insertBefore(nodes)        // [前序插入] 在当前节点同级的上方插入一个或多个节点。\n// path.insertAfter(nodes)         // [后续插入] 在当前节点同级的下方插入一个或多个节点。\n```\n\n### 4.综合运用\n我们还是使用刚才的那个例子来进行逐步解析，这个方法适用于解密函数的反混淆，控制流平坦化的扁平化处理，字符串十六进制的转换，代理函数的还原等。此处为字符串十六进制反混淆。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img12@main/2026/02/11/1770781801059-e52e035f-056c-4c60-af9f-9b73c5326506.png)\n根据 AST 树状图不难看出\n我们想要的字符串字面量（StringLiteral）\n可能嵌套在\n二元表达式（BinaryExpression）或\n表达式语句（ExpressionStatement）中。\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img10@main/2026/02/11/1770782276593-d7831b21-5e76-4a27-84a3-23af9d4ade73.png)\n进入 StringLiteral 节点深处，我们可以发现两个关键属性：\n\nextra.raw: 混淆后的十六进制形式，例如 '\\x61'。\n\nextra.rawValue: Babel 解析后的原始文本，例如 'a'\n\n接下来我们只需要根据这样的节点信息来编写通用的反混淆代码。\n\n\n```js\ntraverse(ast, {\n    //我们通过对比 extra.raw（原始文本）与 extra.rawValue（解析后的实际值），来精准识别出那些被“转义混淆”过的字符串。\n    StringLiteral: function (path) {\n        if (path.node.extra && path.node.extra.raw !== path.node.extra.rawValue) {\n            console.log(path.toString())\n          //通过日志输出可以查验我们想要操作的节点是否正确，它能让你直观地看到当前处理的代码长什么样\n            path.replaceWith(types.stringLiteral(path.node.extra.rawValue));\n          //通过path.replaceWith将原有节点进行替换，types用法见下文。\n        }\n    }\n});\n```\n\n### 5. 常用类型名称及描述\n\n\n![](https://fastly.jsdelivr.net/gh/bucketio/img7@main/2026/02/11/1770782713530-5bca391a-0fe8-4cfb-85f7-ba4b398458d6.png)\n\n\n\n## types\n\n### 1.常用types的is判断\n```js\n// 语法：types.is[节点类型](待检测的节点)\n// 返回：Boolean (true/false)\n\nif (types.isStringLiteral(path.node)) {\n    // 确定是字符串，可以放心访问 path.node.value\n}\n\nif (types.isBinaryExpression(path.node)) {\n    // 确定是二元表达式，可以放心访问 path.node.left 和 path.node.right\n}\n```\n我们还可以看一下源码的写法\n```ts\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  const nodeType = node.type;\n\n  if (nodeType === \"StringLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return (0, _shallowEqual.default)(node, opts);\n    }\n  }\n\n  return false;\n}\n```\n它比` node.type === '...' `更安全，因为它内置了 null 检查。\n### 2. 字面量还原\n这些方法用于将解密后的值还原为代码中的常量\n\n|   方法名    |  说明     |     示例代码  |    还原后的源码   |\n| --- | --- | --- | --- |\n|    `types.stringLiteral(v)`   |   构造字符串    |   ` types.stringLiteral(\"hello\") `  |  \"hello\"     |\n|    `types.numericLiteral(v)`\t   |     构造数字\t |     `types.numericLiteral(123)`\t  |  123      |\n|    `types.booleanLiteral(v)`\t   |    构造布尔值\t   |   `types.booleanLiteral(true)`\t   |  true      |\n|    `types.identifier(v)`   |     构造变量名/标识符  |    `types.identifier(\"user\")`   |    user   |\n\n\n\n### 3. 表达式还原\n当你需要把混淆的调用还原为简单的运算或取值时使用。\n\n|     方法名   |   说明     |    示例代码    |   还原后的源码    |\n| --- | --- | --- | --- |\n|    `types.binaryExpression(op, l, r)`   |   构造二元运算    |   `types.binaryExpression(\"+\", a, b)`    |  a + b     |\n|   `types.callExpression(callee, args)`    |    构造函数调用   |    `types.callExpression(func, [arg1])`   |   func(arg1)    |\n|    `types.memberExpression(obj, prop)`   |  构造对象取值     |    `types.memberExpression(obj, prop)`   |   obj.prop 或 obj[prop]    |\n|   `types.unaryExpression(op, arg)`   |   构造一元运算    |  `types.unaryExpression(\"!\", a)`     |    !a   |\n\n### 4. 剩余好用的API\n(1)`types.matchesPattern(node, pattern, allowPartial)`\n功能：判断一个节点是否匹配指定的成员表达式路径\n实战场景：识别并拦截特定的解密工具类方法。\n ```js\n // 检查当前节点是不是 console.log\nif (types.matchesPattern(path.node, \"console.log\")) {\n    // 逻辑处理\n}\n ```\n (2)`types.cloneNode(node)`\n 功能：深度克隆一个节点及其子节点。\n 实战场景：在还原代理函数或展开表达式时，确保新生成的节点是独立的，不会在修改 A 时意外影响到 B。\n (3)`types.toComputedKey(node)`\n 举例：混淆代码喜欢把 `obj.prop `变成 `obj[\"prop\"]`\n 功能：将节点转换为有效的对象属性键（处理标识符和字符串字面量之间的转换）。\n 实战场景：统一属性访问方式，方便后续的静态分析。\n## Scope\n### 1. 什么是 Scope？\n在 Babel 中，Scope 是一个对象，它代表了代码中的词法作用域（Lexical Scope）。\n\n每一个函数、每一个块级（Block，如 if 或 for）都会生成一个新的 Scope。它负责记录当前区域内定义了哪些变量，以及这些变量被谁引用了。\n\n### 2.有了 Scope 可以完成哪些操作\n\n#### （1）变量重命名还原（Rename）\n\n- 场景：混淆代码喜欢把变量改成 `_0x1abc`\n\n- 操作：`path.scope.rename(\"_0x1abc\", \"decoded_str\")`\n\n- 作用：它不仅改掉定义的那个名字，还会自动把全篇所有引用这个变量的地方全部改掉，且保证不会污染其他同名变量。\n#### （2）解密函数批量内联\n- 场景：你发现` _0x55aa` 是解密函数。\n- 操作：通过 `path.scope.getBinding(\"_0x55aa\")` 拿到它的 referencePaths。\n- 作用：你直接遍历这些路径，挨个执行解密并替换，不需要全局扫描字符串。\n```js\nvar _0x55aa = function(a, b) { ... }; // 定义解密函数\n\nvar alias = _0x55aa;                  // 引用 1：赋值给别名\nconsole.log(_0x55aa);                 // 引用 2：作为参数传递\nvar str = _0x55aa('0x1', '0x2');      // 引用 3：真正的函数调用\n```\n>对代码块举例说明`path.scope.getBinding(\"_0x55aa\").referencePaths` 时，你会拿到 3 个 Path 对象。\n>>引用 1 的 Path 指向的是 `_0x55aa` 这个 Identifier（标识符）。它的父级是 VariableDeclarator。\n>>引用 2 的 Path 指向的是 `_0x55aa` 这个 Identifier。它的父级是 CallExpression (console.log)。\n>>引用 3 的 Path 指向的是 `_0x55aa` 这个 Identifier。它的父级才是真正的解密调用 CallExpression。\n\n我们来对上面这个代码块来做一次还原处理\n```js\n// 1. 获取解密函数的“档案”\nconst binding = path.scope.getBinding(\"_0x55aa\");\n//这个binding.referencePaths可以理解为拿到了所有引用了这个变量的 Path 对象\n// 2. 遍历所有引用了该变量的路径 (List)\nfor (let refPath of binding.referencePaths) {\n    \n    // 3. 拿到当前引用的父级路径\n    const parentPath = refPath.parentPath;\n\n    // 4. 判断逻辑：父级是不是一个函数调用？且当前引用是不是那个被叫名字的人（callee）？\n    if (parentPath.isCallExpression() && parentPath.node.callee === refPath.node) {\n        \n        // 5. 提取参数执行解密（假设参数是第一个）\n        const arg1 = parentPath.node.arguments[0].value;\n        const arg2 = parentPath.node.arguments[1].value;\n        const result = _0x55aa(arg1,arg2); \n        \n        // 6. 替换掉整个调用表达式\n        parentPath.replaceWith(types.stringLiteral(result));\n    }\n}\n```\n大家可以将举例代码块粘贴于`https://astexplorer.net/`\n进行配套理解本段反混淆代码\n这样做的好处是在混淆代码过长，或者有不同函数局部变量导致函数名重复时，实现真实有效的反混淆\n#### （3）删除死代码\n- 场景：很多混淆逻辑会生成一堆从未调用的函数。\n- 操作：检查 `binding.referenced === false`\n- 效果：直接 path.remove()，代码瞬间清爽。\n```js\nvar _0x55aa = function(a, b) { return a + b; }; // 真正的解密函数\nvar _0x123456 = _0x55aa;                       // 垃圾别名：定义了但没人用\nvar _0x999999 = \"I am useless\";                // 纯垃圾变量\n\nconsole.log(_0x55aa(1, 2));                    // 只有这里用到了 _0x55aa\n```\n```js\ntraverse(ast, {\n    // 我们可以针对“变量声明”进行扫描\n    VariableDeclarator(path) {\n        // 1. 获取当前变量名的标识符（Identifier）\n        const { id } = path.node;\n        \n        // 2. 如果不是标识符（比如是解构赋值），跳过\n        if (!types.isIdentifier(id)) return;\n\n        // 3. 索取该变量的“档案”\n        const binding = path.scope.getBinding(id.name);\n\n        // 4. 核心判定：如果没有被引用，且不是全局变量\n        if (binding && !binding.referenced) {\n            console.log(`发现死代码：变量 ${id.name} 无人引用，正在执行清理...`);\n            \n            // 5. 物理删除该节点\n            path.remove();\n        }\n    }\n});\n```\n#### (4) scope.getBinding()\n单独拿出来说是因为其本身就很复杂\n\n当你执行 getBinding 时，Babel 会瞬间把这个变量在整个作用域链（Scope Chain）上的所有信息抽调出来。\n\n它有一个向上溯源的属性，会一直向父级，爷爷级向上找，直到全局作用域。\n```js\n// binding = path.scope.getBinding(\"变量名\")\n\n// 1. binding.path \n// 这是一个指向“声明节点（Declaration）”的 NodePath 对象。\n// 用途：你可以直接通过 binding.path.node 获取变量的初始化值。\n\n// 2. binding.referencePaths \n// 这是一个由 NodePath 对象组成的 Array（数组）。\n// 用途：记录了全篇所有引用该变量的地方。\n\n// 3. binding.constant\n// 这是一个 Boolean（布尔值）。\n// 用途：如果变量定义后从未出现在赋值号左侧（没被改过），则为 true。\n```\n### 3.常用api汇总\n\n|     API 方法  |     作用说明  |\n| --- | --- |\n|    path.scope.getBinding(name)   |   获取某个变量的详细档案（Binding）。    |\n|    path.scope.hasBinding(name)   |   判断当前作用域（含父级）是否定义了该变量。    |\n|    path.scope.hasOwnBinding(name)   |    只在当前作用域寻找定义。   |\n|    path.scope.generateUid(name)   |   生成一个当前作用域内唯一的变量名（防冲突）。    |\n|     path.scope.dump()  |    调试利器！ 打印当前作用域的所有变量信息到控制台。   |\n\n\n## 总结\n在代码的废墟中，所有的混乱都遵循着某种秩序。而 AST，就是我们重建秩序的蓝图。\n\n由于 AST 混淆技术博大精深，本人水平有限，文中若有疏漏或理解偏差之处，恳请各位前辈大佬不吝赐教，我们评论区见。\n\n希望我的内容能够帮助到您，如果有侵权或冒犯的地方请私信我。\n\n最后，愿我们在高处相见，亦或在深处重逢。\n- [什么是ast，怎么用ast，ast的一些思考](https://mp.weixin.qq.com/s/LUuv2QEvOP2tkzQGx8iRGg)\n\n\n---\n\n\n   ![](https://fastly.jsdelivr.net/gh/bucketio/img4@main/2026/02/11/1770791852679-7134300f-96f4-4f02-a06a-86e130e060c5.jpg)\n\n","categories":["featTest"]},{"title":"一切的开始","url":"/2026/01/13/第一篇博客/","content":"# 一级标题\n## 二级标题\n### 三级标题","categories":["featTest"]}]